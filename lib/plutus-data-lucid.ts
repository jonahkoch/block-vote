/**
 * Plutus Data Serialization for Lucid Evolution
 *
 * Converts TypeScript types to Plutus Data format for on-chain validators
 * Based on the Aiken schema in plutus.json
 *
 * IMPORTANT: For Lucid Evolution's Data.to() to work:
 * - Use Constr class for constructors: new Constr(index, fields)
 * - ByteArray: pass hex string directly
 * - Int: use BigInt
 * - Lists: use arrays
 * - All fields must be valid Data types (Constr, bigint, string, Array, Map)
 */

import type {
  Credential,
  GovernancePactDatum,
  DistributionDatum,
  MintRedeemer,
} from '../types/contracts';
import type { Constr, Data } from '@lucid-evolution/lucid';

// ============================================================================
// Helper: Convert string to hex (UTF-8)
// ============================================================================

function stringToHex(str: string): string {
  return Buffer.from(str, 'utf8').toString('hex');
}

// ============================================================================
// Credential Conversion
// ============================================================================

/**
 * Convert Credential to Plutus Data structure using Constr
 *
 * Schema:
 * - VerificationKey (constructor 0): [ VerificationKeyHash ]
 * - Script (constructor 1): [ ScriptHash ]
 *
 * NOTE: Constr will be imported dynamically in the calling code
 */
export function credentialToData(credential: Credential, Constr: any): Data {
  if (credential.type === 'VerificationKey') {
    return new Constr(0, [credential.hash]);
  } else {
    // Script
    return new Constr(1, [credential.hash]);
  }
}

// ============================================================================
// Address Conversion (Simplified for MVP)
// ============================================================================

/**
 * Convert Bech32 address and script hash to Plutus Address structure using Constr
 *
 * For script addresses generated by getValidatorAddress(), we need to use
 * the original script hash, not parse the Bech32 address.
 *
 * Schema:
 * Address (constructor 0):
 *   - payment_credential: Credential (Script with hash)
 *   - stake_credential: Option (None)
 *
 * @param scriptHash - The original script hash (NOT the Bech32 address)
 * @param Constr - Constr class from Lucid Evolution
 */
export function scriptHashToAddressData(scriptHash: string, Constr: any): Data {
  return new Constr(0, [
    // payment_credential: Script type (constructor 1) with hash
    new Constr(1, [scriptHash]),
    // stake_credential: None (constructor 1)
    new Constr(1, []),
  ]);
}

// ============================================================================
// GovernancePactDatum Conversion
// ============================================================================

/**
 * Convert GovernancePactDatum to Plutus Data structure using Constr
 *
 * Schema (11 fields):
 * 0: title (ByteArray)
 * 1: description (ByteArray)
 * 2: cardano_action_id (ByteArray)
 * 3: cardano_action_type (ByteArray)
 * 4: voting_deadline (Int)
 * 5: total_members (Int)
 * 6: required_votes (Int)
 * 7: policy_id (ByteArray)
 * 8: asset_name (ByteArray)
 * 9: metadata_validator (Address)
 * 10: distribution_validator (Address)
 *
 * NOTE: The metadataValidator and distributionValidator fields should contain
 * Bech32 addresses, but we need to extract the script hash from them.
 * For now, we expect the TypeScript type to actually contain script hashes.
 */
export function governancePactDatumToData(
  datum: GovernancePactDatum,
  metadataScriptHash: string,
  distributionScriptHash: string,
  Constr: any
): Data {
  return new Constr(0, [
    stringToHex(datum.title),
    stringToHex(datum.description),
    stringToHex(datum.cardanoActionId),
    stringToHex(datum.cardanoActionType),
    BigInt(datum.votingDeadline),
    BigInt(datum.totalMembers),
    BigInt(datum.requiredVotes),
    datum.policyId,
    stringToHex(datum.assetName),
    scriptHashToAddressData(metadataScriptHash, Constr),
    scriptHashToAddressData(distributionScriptHash, Constr),
  ]);
}

// ============================================================================
// DistributionDatum Conversion
// ============================================================================

/**
 * Convert DistributionDatum to Plutus Data structure using Constr
 *
 * Schema (4 fields):
 * 0: qualified_members (List<Credential>)
 * 1: policy_id (ByteArray)
 * 2: user_token_name (ByteArray)
 * 3: total_tokens (Int)
 */
export function distributionDatumToData(datum: DistributionDatum, Constr: any): Data {
  const credentialsList = datum.qualifiedMembers.map(cred => credentialToData(cred, Constr));

  return new Constr(0, [
    credentialsList,
    datum.policyId,
    datum.userTokenName,
    BigInt(datum.totalTokens),
  ]);
}

// ============================================================================
// MintRedeemer Conversion (CreatePact)
// ============================================================================

/**
 * Convert MintRedeemer (CreatePact) to Plutus Data structure using Constr
 *
 * Schema:
 * Constructor 0 (CreatePact):
 * 0: qualified_members (List<Credential>)
 * 1: pact_datum (GovernancePactDatum)
 */
export function mintRedeemerToData(
  redeemer: MintRedeemer,
  metadataScriptHash: string,
  distributionScriptHash: string,
  Constr: any
): Data {
  const credentialsList = redeemer.qualifiedMembers.map(cred => credentialToData(cred, Constr));
  const pactDatumData = governancePactDatumToData(
    redeemer.pactDatum,
    metadataScriptHash,
    distributionScriptHash,
    Constr
  );

  return new Constr(0, [
    credentialsList,
    pactDatumData,
  ]);
}

// ============================================================================
// Other Redeemers
// ============================================================================

/**
 * ClaimToken redeemer (constructor 0, no fields)
 */
export function claimTokenRedeemerToData(Constr: any): Data {
  return new Constr(0, []);
}

/**
 * UnlockAfterVoting redeemer (constructor 0, no fields)
 */
export function unlockAfterVotingRedeemerToData(Constr: any): Data {
  return new Constr(0, []);
}

/**
 * CastVote redeemer (constructor 0, with vote choice field)
 */
export function castVoteRedeemerToData(vote: 'Yes' | 'No', Constr: any): Data {
  const voteChoice = vote === 'Yes'
    ? new Constr(0, [])
    : new Constr(1, []);

  return new Constr(0, [voteChoice]);
}
